<script>
    /**
     * Telegram скрипт с Polling localStorage + beforeunload (без API перехвата)
     * РАЗМЕЩЕНИЕ: В FOOTER сайта (перед закрывающим </body>)
     */

    console.log('[TELEGRAM] Скрипт с Polling + beforeunload загружен');

    const TELEGRAM_BOT_TOKEN = '8111231642:AAE6FjAyI5B_zMcokXQ1KPpSU7ZZ2S76DXI';
    const TELEGRAM_CHAT_ID = '481014845';

    // Глобальный флаг для предотвращения дублирования
    let isOrderSending = false;
    let orderSent = false;

    // Функция для постоянного логирования
    function logToLocalStorage(message) {
        try {
            const logs = JSON.parse(localStorage.getItem('telegram_debug_logs') || '[]');
            const timestamp = new Date().toISOString();
            logs.push(`${timestamp}: ${message}`);

            if (logs.length > 100) {
                logs.splice(0, logs.length - 100);
            }

            localStorage.setItem('telegram_debug_logs', JSON.stringify(logs));
            console.log('[TELEGRAM DEBUG]', message);
        } catch (error) {
            console.log('[TELEGRAM DEBUG ERROR]', error);
        }
    }

    // Функция для конвертации base64 в Blob
    function base64ToBlob(base64Data, contentType = '') {
        const byteCharacters = atob(base64Data.split(',')[1]);
        const byteNumbers = new Array(byteCharacters.length);

        for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
        }

        const byteArray = new Uint8Array(byteNumbers);
        return new Blob([byteArray], { type: contentType });
    }

    // Функция для получения данных клиента
    function getCustomerData() {
        logToLocalStorage('Получаем данные клиента');

        let customerData = {
            name: 'Не указано',
            email: 'Не указано',
            phone: 'Не указано'
        };

        // Проверяем сохраненные данные из localStorage
        try {
            const savedData = localStorage.getItem('tilda_customer_data');
            if (savedData) {
                const parsed = JSON.parse(savedData);
                if (parsed.name && parsed.name !== 'Не указано') customerData.name = parsed.name;
                if (parsed.email && parsed.email !== 'Не указано') customerData.email = parsed.email;
                if (parsed.phone && parsed.phone !== 'Не указано') customerData.phone = parsed.phone;
                logToLocalStorage(`Данные клиента из localStorage: ${JSON.stringify(parsed)}`);
            }
        } catch (error) {
            logToLocalStorage(`Ошибка чтения данных клиента: ${error.message}`);
        }

        // Дополнительный поиск в активных формах на странице
        const nameSelectors = [
            'input[name="name"]', 'input[data-tilda-rule="name"]',
            'input[name="Name"]', 'input[placeholder*="имя"]'
        ];
        const emailSelectors = [
            'input[name="email"]', 'input[data-tilda-rule="email"]',
            'input[type="email"]', 'input[name="Email"]'
        ];
        const phoneSelectors = [
            'input[name="phone"]', 'input[data-tilda-rule="phone"]',
            'input[type="tel"]', 'input[name="Phone"]'
        ];

        // Поиск активных данных в формах
        for (const selector of nameSelectors) {
            const element = document.querySelector(selector);
            if (element && element.value && element.value.trim()) {
                customerData.name = element.value.trim();
                break;
            }
        }

        for (const selector of emailSelectors) {
            const element = document.querySelector(selector);
            if (element && element.value && element.value.trim()) {
                customerData.email = element.value.trim();
                break;
            }
        }

        for (const selector of phoneSelectors) {
            const element = document.querySelector(selector);
            if (element && element.value && element.value.trim()) {
                customerData.phone = element.value.trim();
                break;
            }
        }

        logToLocalStorage(`Итоговые данные клиента: ${JSON.stringify(customerData)}`);
        return customerData;
    }

    // Функция получения номера заказа
    function getOrderNumber() {
        const orderId = localStorage.getItem('tilda_order_id');
        if (orderId) {
            logToLocalStorage(`Найден номер заказа: ${orderId}`);
            return orderId;
        }
        return '';
    }

    // Функция проверки наличия товаров в IndexedDB
    async function hasOrderProducts() {
        if (!window.TildaCartDB) {
            logToLocalStorage('TildaCartDB недоступен');
            return false;
        }

        try {
            const db = new TildaCartDB();
            await db.init();
            const products = await db.getAllProducts();
            const hasProducts = products.length > 0;
            logToLocalStorage(`Товаров в IndexedDB: ${products.length}`);
            return hasProducts;
        } catch (error) {
            logToLocalStorage(`Ошибка проверки товаров: ${error.message}`);
            return false;
        }
    }

    // Функция получения товаров для отправки
    async function getOrderProducts() {
        if (!window.TildaCartDB) return [];

        try {
            const db = new TildaCartDB();
            await db.init();
            const products = await db.getAllProducts();

            logToLocalStorage(`Получено товаров для отправки: ${products.length}`);
            return products;
        } catch (error) {
            logToLocalStorage(`Ошибка получения товаров: ${error.message}`);
            return [];
        }
    }

    // ОСНОВНАЯ функция отправки заказа
    async function sendOrderToTelegram() {
        // Защита от дублирования
        if (isOrderSending || orderSent) {
            logToLocalStorage('Отправка уже выполняется или завершена, пропускаем');
            return false;
        }

        isOrderSending = true;
        logToLocalStorage('НАЧИНАЕМ ОТПРАВКУ ЗАКАЗА В TELEGRAM');

        try {
            // Получаем все данные
            const customer = getCustomerData();
            const orderNumber = getOrderNumber();
            const products = await getOrderProducts();

            if (!orderNumber) {
                logToLocalStorage('Нет номера заказа, отменяем отправку');
                isOrderSending = false;
                return false;
            }

            if (products.length === 0) {
                logToLocalStorage('Нет товаров в заказе, отменяем отправку');
                isOrderSending = false;
                return false;
            }

            // Формируем сообщение
            let message = 'НОВЫЙ ЗАКАЗ - ОЖИДАЕМ ОПЛАТУ!\n\n';
            message += `Номер заказа: ${orderNumber}\n\n`;
            message += `Клиент: ${customer.name}\n`;
            message += `Email: ${customer.email}\n`;
            message += `Телефон: ${customer.phone}\n`;
            message += `Дата: ${new Date().toLocaleString('ru-RU')}\n\n`;

            let files = [];
            let totalAmount = 0;

            // Обрабатываем товары
            message += `Товары в заказе:\n`;
            products.forEach((product, i) => {
                message += `\n${i + 1}. ${product.productName || 'Товар'}\n`;
                if (product.text) {
                    message += `Текст: ${product.text}\n`;
                }
                message += `SKU: ${product.sku || 'Не указан'}\n`;
                message += `Кол-во: 1\n`;

                // Получаем цену
                const productPrice = product.price || '0';
                message += `Цена: ${productPrice} РУБ\n`;

                const priceNumber = parseFloat(productPrice.toString().replace(/[^\d.,]/g, '').replace(',', '.')) || 0;
                totalAmount += priceNumber;

                // Подготавливаем файл
                if (product.file && product.file.data) {
                    const blob = base64ToBlob(product.file.data, product.file.type);
                    files.push({
                        name: product.file.name || 'file.jpg',
                        blob: blob,
                        productName: product.productName || 'Товар'
                    });
                    message += `К товару прикреплен файл\n`;
                }
            });

            if (files.length > 0) {
                message += `\nВсего файлов: ${files.length}\n`;
            }

            message += `\nОбщая сумма: ${totalAmount} РУБ\n`;
            message += `СТАТУС: ОЖИДАЕМ ОПЛАТУ\n`;

            logToLocalStorage(`Подготовлено к отправке: товаров ${products.length}, файлов ${files.length}, сумма ${totalAmount}`);

            // Отправляем сообщение
            const response = await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    chat_id: TELEGRAM_CHAT_ID,
                    text: message
                })
            });

            const result = await response.json();
            if (!result.ok) {
                logToLocalStorage(`Ошибка отправки сообщения: ${result.description}`);
                isOrderSending = false;
                return false;
            }

            logToLocalStorage('Текстовое сообщение отправлено успешно');

            // Отправляем файлы
            if (files.length > 0) {
                for (let fileObj of files) {
                    try {
                        const formData = new FormData();
                        formData.append('chat_id', TELEGRAM_CHAT_ID);
                        formData.append('caption', `${fileObj.productName} - ${fileObj.name}`);
                        formData.append('document', fileObj.blob, fileObj.name);

                        const fileResp = await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendDocument`, {
                            method: 'POST',
                            body: formData
                        });

                        const fileJson = await fileResp.json();
                        if (fileJson.ok) {
                            logToLocalStorage(`Файл отправлен: ${fileObj.name}`);
                        } else {
                            logToLocalStorage(`Ошибка отправки файла ${fileObj.name}: ${fileJson.description}`);
                        }
                    } catch (fileError) {
                        logToLocalStorage(`Сетевая ошибка файла ${fileObj.name}: ${fileError.message}`);
                    }
                }
            }

            // Помечаем что заказ отправлен
            orderSent = true;
            localStorage.setItem('telegram_sent', 'true');
            localStorage.setItem('telegram_sent_time', new Date().toISOString());
            logToLocalStorage('ЗАКАЗ УСПЕШНО ОТПРАВЛЕН В TELEGRAM');

            // Очищаем IndexedDB
            await cleanupIndexedDB();

            return true;

        } catch (error) {
            logToLocalStorage(`ОШИБКА ОТПРАВКИ: ${error.message}`);
            return false;
        } finally {
            isOrderSending = false;
        }
    }

    // Быстрая отправка для beforeunload (только текст, без файлов)
    function quickSendOrderNotification() {
        if (isOrderSending || orderSent) {
            logToLocalStorage('Быстрая отправка: заказ уже обработан');
            return;
        }

        logToLocalStorage('БЫСТРАЯ ОТПРАВКА перед уходом со страницы');

        const orderNumber = getOrderNumber();
        if (!orderNumber) {
            logToLocalStorage('Быстрая отправка: нет номера заказа');
            return;
        }

        const customer = getCustomerData();

        let message = 'СРОЧНО! Пользователь ушел со страницы\n\n';
        message += `Номер заказа: ${orderNumber}\n`;
        message += `Клиент: ${customer.name}\n`;
        message += `Email: ${customer.email}\n`;
        message += `Телефон: ${customer.phone}\n`;
        message += `СТАТУС: Ушел на оплату (файлы будут отправлены позже)\n`;

        // Используем sendBeacon для гарантированной отправки
        const data = new FormData();
        data.append('chat_id', TELEGRAM_CHAT_ID);
        data.append('text', message);

        try {
            navigator.sendBeacon(
                `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`,
                data
            );

            orderSent = true;
            localStorage.setItem('telegram_sent', 'true');
            logToLocalStorage('Быстрая отправка выполнена через sendBeacon');
        } catch (error) {
            logToLocalStorage(`Ошибка быстрой отправки: ${error.message}`);
        }
    }

    // Очистка IndexedDB после отправки
    async function cleanupIndexedDB() {
        if (!window.TildaCartDB) {
            logToLocalStorage('TildaCartDB недоступен для очистки');
            return;
        }

        try {
            const db = new TildaCartDB();
            await db.init();
            await db.clearAllProducts();
            logToLocalStorage('IndexedDB очищен после отправки');
        } catch (error) {
            logToLocalStorage(`Ошибка очистки IndexedDB: ${error.message}`);
        }
    }

    // Проверка условий для отправки заказа
    async function shouldSendOrder() {
        // Уже отправлен?
        if (orderSent || localStorage.getItem('telegram_sent')) {
            return false;
        }

        // Есть номер заказа?
        const orderId = getOrderNumber();
        if (!orderId) {
            return false;
        }

        // Есть товары?
        const hasProducts = await hasOrderProducts();
        if (!hasProducts) {
            return false;
        }

        return true;
    }

    // ОСНОВНАЯ ФУНКЦИЯ: Polling localStorage
    async function startPollingLocalStorage() {
        logToLocalStorage('Запускаем polling localStorage каждые 2 секунды');

        setInterval(async () => {
            try {
                if (await shouldSendOrder()) {
                    logToLocalStorage('POLLING: Найден заказ для отправки!');
                    await sendOrderToTelegram();
                }
            } catch (error) {
                logToLocalStorage(`Ошибка в polling: ${error.message}`);
            }
        }, 2000); // Проверяем каждые 2 секунды
    }

    // ДОПОЛНИТЕЛЬНАЯ ФУНКЦИЯ: beforeunload защита
    function setupBeforeUnloadProtection() {
        logToLocalStorage('Устанавливаем beforeunload защиту');

        window.addEventListener('beforeunload', function (event) {
            logToLocalStorage('beforeunload: Пользователь покидает страницу');

            // Быстрая проверка условий
            const orderId = getOrderNumber();
            const alreadySent = orderSent || localStorage.getItem('telegram_sent');

            if (orderId && !alreadySent && !isOrderSending) {
                logToLocalStorage('beforeunload: Выполняем быструю отправку');
                quickSendOrderNotification();
            }
        });
    }

    // Функция сброса состояния при новом заказе
    function resetOrderState() {
        orderSent = false;
        isOrderSending = false;
        localStorage.removeItem('telegram_sent');
        localStorage.removeItem('telegram_sent_time');
        logToLocalStorage('Состояние заказа сброшено');
    }

    // Глобальные функции для управления и отладки
    window.telegramSimple = {
        async sendOrder() {
            logToLocalStorage('ПРИНУДИТЕЛЬНАЯ отправка заказа');
            resetOrderState();
            return await sendOrderToTelegram();
        },

        async checkOrder() {
            const orderId = getOrderNumber();
            const hasProducts = await hasOrderProducts();
            const shouldSend = await shouldSendOrder();
            const customer = getCustomerData();

            const orderStatus = {
                orderId,
                hasProducts,
                shouldSend,
                orderSent,
                isOrderSending,
                customer
            };

            console.log('=== СТАТУС ЗАКАЗА ===', orderStatus);
            return orderStatus;
        },

        async checkProducts() {
            const products = await getOrderProducts();
            console.log('[TELEGRAM] Товары в заказе:', products);
            return products;
        },

        showLogs() {
            const logs = JSON.parse(localStorage.getItem('telegram_debug_logs') || '[]');
            console.log('=== TELEGRAM LOGS ===');
            logs.forEach(log => console.log(log));
            return logs;
        },

        clearLogs() {
            localStorage.removeItem('telegram_debug_logs');
            logToLocalStorage('Логи очищены');
        },

        resetState() {
            resetOrderState();
            console.log('[TELEGRAM] Состояние сброшено');
        },

        clearStorage() {
            localStorage.removeItem('tilda_order_id');
            localStorage.removeItem('tilda_customer_data');
            localStorage.removeItem('telegram_sent');
            localStorage.removeItem('telegram_sent_time');
            resetOrderState();
            logToLocalStorage('Все данные очищены');
        },

        // Функция для тестирования быстрой отправки
        testQuickSend() {
            logToLocalStorage('ТЕСТ быстрой отправки');
            quickSendOrderNotification();
        },

        // Полная диагностика
        async fullDiagnostic() {
            console.log('=== ПОЛНАЯ ДИАГНОСТИКА ===');
            const diagnostic = {
                timestamp: new Date().toISOString(),
                orderStatus: await this.checkOrder(),
                products: await this.checkProducts(),
                logs: this.showLogs().slice(-10) // Последние 10 записей
            };
            console.log('ДИАГНОСТИКА:', diagnostic);
            return diagnostic;
        }
    };

    // Инициализация при загрузке страницы
    function initializeTelegramScript() {
        logToLocalStorage('Инициализация Telegram скрипта');

        // Проверяем что уже было отправлено
        if (localStorage.getItem('telegram_sent')) {
            orderSent = true;
            logToLocalStorage('Обнаружена предыдущая отправка');
        }

        // Запускаем основные функции
        startPollingLocalStorage();
        setupBeforeUnloadProtection();

        logToLocalStorage('Telegram скрипт полностью инициализирован');
    }

    // Запуск при загрузке документа
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeTelegramScript);
    } else {
        initializeTelegramScript();
    }

    console.log(`
=== TELEGRAM СКРИПТ С POLLING + BEFOREUNLOAD ===
Скрипт успешно загружен!

ПРИНЦИП РАБОТЫ:
• Polling localStorage каждые 2 секунды
• Мгновенная отправка при появлении orderId
• beforeunload защита от потери заказов
• Защита от дублирования отправки

КОМАНДЫ ДЛЯ ОТЛАДКИ:
• window.telegramSimple.checkOrder() - статус заказа
• window.telegramSimple.sendOrder() - принудительная отправка
• window.telegramSimple.checkProducts() - товары в заказе
• window.telegramSimple.fullDiagnostic() - полная диагностика
• window.telegramSimple.showLogs() - показать логи
• window.telegramSimple.testQuickSend() - тест быстрой отправки
• window.telegramSimple.resetState() - сброс состояния
• window.telegramSimple.clearStorage() - очистить все данные

ОСОБЕННОСТИ:
• Максимальная задержка: 2 секунды (polling)
• Двойная защита: polling + beforeunload
• Автоочистка IndexedDB после отправки
• Быстрая отправка через sendBeacon
• Защита от повторной отправки
`);
</script>