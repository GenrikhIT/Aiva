<script>
    /**
     * Доработанный Telegram скрипт с УСИЛЕННЫМ перехватом и записью tilda_order_id
     * РАЗМЕЩЕНИЕ: В FOOTER сайта (перед закрывающим </body>)
     */

    console.log('[TELEGRAM] Доработанный скрипт с усиленным перехватом загружен');

    const TELEGRAM_BOT_TOKEN = '8111231642:AAE6FjAyI5B_zMcokXQ1KPpSU7ZZ2S76DXI';
    const TELEGRAM_CHAT_ID = '481014845';

    // Функция для постоянного логирования (не пропадает при переходах)
    function logToLocalStorage(message) {
        try {
            const logs = JSON.parse(localStorage.getItem('telegram_debug_logs') || '[]');
            const timestamp = new Date().toISOString();
            logs.push(`${timestamp}: ${message}`);

            // Оставляем только последние 100 записей
            if (logs.length > 100) {
                logs.splice(0, logs.length - 100);
            }

            localStorage.setItem('telegram_debug_logs', JSON.stringify(logs));
            console.log('[TELEGRAM DEBUG]', message);
        } catch (error) {
            console.log('[TELEGRAM DEBUG ERROR]', error);
        }
    }

    // Функция для конвертации base64 в Blob
    function base64ToBlob(base64Data, contentType = '') {
        const byteCharacters = atob(base64Data.split(',')[1]);
        const byteNumbers = new Array(byteCharacters.length);

        for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
        }

        const byteArray = new Uint8Array(byteNumbers);
        return new Blob([byteArray], { type: contentType });
    }

    // Функция для получения данных клиента из форм
    function getCustomerData() {
        const customerData = {
            name: 'Не указано',
            email: 'Не указано',
            phone: 'Не указано'
        };

        logToLocalStorage('Начинаем поиск данных клиента');

        // Расширенный поиск по всем возможным селекторам
        const nameSelectors = [
            'input[name="name"]',
            'input[name="Name"]',
            'input[name="firstname"]',
            'input[name="FirstName"]',
            'input[placeholder*="имя"]',
            'input[placeholder*="Имя"]',
            'input[data-tilda-rule="name"]',
            'input[data-field="name"]',
            '.js-tilda-rule input[data-tilda-rule="name"]',
            '.t-input[data-tilda-rule="name"]'
        ];

        const emailSelectors = [
            'input[name="email"]',
            'input[name="Email"]',
            'input[type="email"]',
            'input[data-tilda-rule="email"]',
            'input[data-field="email"]',
            '.js-tilda-rule input[data-tilda-rule="email"]',
            '.t-input[data-tilda-rule="email"]'
        ];

        const phoneSelectors = [
            'input[name="phone"]',
            'input[name="Phone"]',
            'input[name="tel"]',
            'input[type="tel"]',
            'input[data-tilda-rule="phone"]',
            'input[data-field="phone"]',
            '.js-tilda-rule input[data-tilda-rule="phone"]',
            '.t-input[data-tilda-rule="phone"]'
        ];

        // Поиск имени
        for (const selector of nameSelectors) {
            const element = document.querySelector(selector);
            if (element && element.value && element.value.trim()) {
                customerData.name = element.value.trim();
                logToLocalStorage(`Имя найдено: ${customerData.name} через ${selector}`);
                break;
            }
        }

        // Поиск email
        for (const selector of emailSelectors) {
            const element = document.querySelector(selector);
            if (element && element.value && element.value.trim()) {
                customerData.email = element.value.trim();
                logToLocalStorage(`Email найден: ${customerData.email} через ${selector}`);
                break;
            }
        }

        // Поиск телефона
        for (const selector of phoneSelectors) {
            const element = document.querySelector(selector);
            if (element && element.value && element.value.trim()) {
                customerData.phone = element.value.trim();
                logToLocalStorage(`Телефон найден: ${customerData.phone} через ${selector}`);
                break;
            }
        }

        // Поиск в корзине ST100
        const cartForm = document.querySelector('.js-store-cart-form, .js-cart-form');
        if (cartForm) {
            logToLocalStorage('Найдена форма корзины ST100');

            const cartNameField = cartForm.querySelector('input[name="name"], input[data-tilda-rule="name"]');
            const cartEmailField = cartForm.querySelector('input[name="email"], input[data-tilda-rule="email"]');
            const cartPhoneField = cartForm.querySelector('input[name="phone"], input[data-tilda-rule="phone"]');

            if (cartNameField && cartNameField.value && cartNameField.value.trim()) {
                customerData.name = cartNameField.value.trim();
                logToLocalStorage(`Имя из корзины: ${customerData.name}`);
            }
            if (cartEmailField && cartEmailField.value && cartEmailField.value.trim()) {
                customerData.email = cartEmailField.value.trim();
                logToLocalStorage(`Email из корзины: ${customerData.email}`);
            }
            if (cartPhoneField && cartPhoneField.value && cartPhoneField.value.trim()) {
                customerData.phone = cartPhoneField.value.trim();
                logToLocalStorage(`Телефон из корзины: ${customerData.phone}`);
            }
        }

        // Дополнительная проверка в сохраненных данных
        try {
            const savedCustomerData = localStorage.getItem('tilda_customer_data');
            if (savedCustomerData) {
                const parsed = JSON.parse(savedCustomerData);
                if (parsed.name && parsed.name !== 'Не указано') customerData.name = parsed.name;
                if (parsed.email && parsed.email !== 'Не указано') customerData.email = parsed.email;
                if (parsed.phone && parsed.phone !== 'Не указано') customerData.phone = parsed.phone;
                logToLocalStorage(`Данные из localStorage: ${JSON.stringify(parsed)}`);
            }
        } catch (error) {
            logToLocalStorage(`Ошибка чтения localStorage: ${error.message}`);
        }

        logToLocalStorage(`Итоговые данные клиента: ${JSON.stringify(customerData)}`);
        return customerData;
    }

    // Функция для получения номера заказа из localStorage
    function getOrderNumber() {
        const savedOrderId = localStorage.getItem('tilda_order_id');
        if (savedOrderId) {
            logToLocalStorage(`Найден номер заказа: ${savedOrderId}`);
            return savedOrderId;
        }

        logToLocalStorage('Номер заказа не найден');
        return '';
    }

    // НОВАЯ ФУНКЦИЯ: Получение только текущего заказа из IndexedDB
    async function getCurrentOrderProducts() {
        if (!window.TildaCartDB) {
            logToLocalStorage('TildaCartDB недоступен');
            return [];
        }

        try {
            const db = new TildaCartDB();
            await db.init();
            const allProducts = await db.getAllProducts();

            logToLocalStorage(`Всего товаров в IndexedDB: ${allProducts.length}`);

            // Получаем время создания текущего заказа
            const orderTime = localStorage.getItem('order_created_time');
            if (!orderTime) {
                logToLocalStorage('Нет времени создания заказа, берем все товары');
                return allProducts;
            }

            const orderTimestamp = parseInt(orderTime);
            const timeThreshold = 5 * 60 * 1000; // 5 минут

            // Фильтруем товары по времени (только недавно добавленные)
            const currentProducts = allProducts.filter(product => {
                if (!product.timestamp) return true; // Если нет timestamp, включаем
                const timeDiff = Math.abs(orderTimestamp - product.timestamp);
                return timeDiff < timeThreshold;
            });

            logToLocalStorage(`Товаров текущего заказа: ${currentProducts.length}`);
            return currentProducts;

        } catch (error) {
            logToLocalStorage(`Ошибка получения товаров: ${error.message}`);
            return [];
        }
    }

    // УЛУЧШЕННАЯ функция отправки заказа в Telegram (с защитой от дублирования)
    async function sendOrderToTelegram() {
        // Дополнительная защита от одновременных вызовов
        if (window.telegramSending) {
            logToLocalStorage('⚠️ Отправка уже в процессе, пропускаем');
            return false;
        }

        window.telegramSending = true;

        try {
            logToLocalStorage('НАЧИНАЕМ ОТПРАВКУ ЗАКАЗА В TELEGRAM');

            // Проверяем что не отправляли уже
            const alreadySent = localStorage.getItem('telegram_sent');
            if (alreadySent) {
                logToLocalStorage('Заказ уже отправлен ранее, пропускаем');
                return false;
            }

            // Получаем данные клиента
            const customer = getCustomerData();

            // Получаем номер заказа
            const orderNumber = getOrderNumber();

            let message = 'НОВЫЙ ЗАКАЗ - ОЖИДАЕМ ОПЛАТУ!\n\n';

            // Добавляем номер заказа если есть
            if (orderNumber) {
                message += `Номер заказа: ${orderNumber}\n\n`;
            }

            message += `Клиент: ${customer.name}\n`;
            message += `Email: ${customer.email}\n`;
            message += `Телефон: ${customer.phone}\n`;
            message += `Дата: ${new Date().toLocaleString('ru-RU')}\n\n`;

            let files = [];
            let totalAmount = 0;

            // ИСПОЛЬЗУЕМ НОВУЮ ФУНКЦИЮ для получения только текущих товаров
            const products = await getCurrentOrderProducts();

            if (products.length > 0) {
                message += `Товары в заказе:\n`;
                products.forEach((product, i) => {
                    message += `\n${i + 1}. ${product.productName || 'Товар'}\n`;
                    if (product.text) {
                        message += `Текст: ${product.text}\n`;
                    }
                    message += `SKU: ${product.sku || 'Не указан'}\n`;
                    message += `Кол-во: 1\n`;

                    // УЛУЧШЕННОЕ получение цены
                    let productPrice = '0';

                    // Приоритет 1: Цена из продукта
                    if (product.price && product.price.toString().trim()) {
                        productPrice = product.price.toString();
                    }
                    // Приоритет 2: Цена из API ответа (если была получена)
                    else {
                        const savedApiPrice = localStorage.getItem('last_api_price');
                        if (savedApiPrice) {
                            productPrice = savedApiPrice;
                            logToLocalStorage(`Используем цену из API: ${productPrice}`);
                        }
                    }

                    message += `Цена: ${productPrice} РУБ\n`;

                    // Добавляем к общей сумме
                    const priceNumber = parseFloat(productPrice.toString().replace(/[^\d.,]/g, '').replace(',', '.')) || 0;
                    totalAmount += priceNumber;

                    // Подготавливаем файл
                    if (product.file && product.file.data) {
                        const blob = base64ToBlob(product.file.data, product.file.type);
                        files.push({
                            name: product.file.name || 'file.jpg',
                            blob: blob,
                            productName: product.productName || 'Товар'
                        });
                        message += `К товару прикреплен файл\n`;
                    }
                });

                if (files.length > 0) {
                    message += `\nВсего файлов: ${files.length}\n`;
                }

                // Используем рассчитанную общую сумму
                message += `\nОбщая сумма: ${totalAmount} РУБ\n`;
                message += `СТАТУС: ОЖИДАЕМ ОПЛАТУ\n`;

                logToLocalStorage(`Рассчитанная сумма: ${totalAmount}`);

            } else {
                message += `Товары: Не найдены в IndexedDB\n`;
                logToLocalStorage('Товары не найдены в IndexedDB');
            }

            try {
                logToLocalStorage('Отправляем текстовое сообщение в Telegram');

                // 1. Отправляем текстовое сообщение
                const response = await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: TELEGRAM_CHAT_ID,
                        text: message
                    })
                });

                const result = await response.json();
                if (!result.ok) {
                    logToLocalStorage(`Ошибка отправки сообщения: ${result.description}`);
                    return false;
                }

                logToLocalStorage('Текстовое сообщение отправлено успешно');

                // 2. Отправляем файлы
                if (files.length > 0) {
                    logToLocalStorage(`Отправляем ${files.length} файлов`);

                    for (let fileObj of files) {
                        const formData = new FormData();
                        formData.append('chat_id', TELEGRAM_CHAT_ID);
                        formData.append('caption', `${fileObj.productName} - ${fileObj.name}`);
                        formData.append('document', fileObj.blob, fileObj.name);

                        try {
                            const fileResp = await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendDocument`, {
                                method: 'POST',
                                body: formData
                            });

                            const fileJson = await fileResp.json();
                            if (fileJson.ok) {
                                logToLocalStorage(`Файл отправлен: ${fileObj.name}`);
                            } else {
                                logToLocalStorage(`Ошибка отправки файла ${fileObj.name}: ${fileJson.description}`);
                            }
                        } catch (fileError) {
                            logToLocalStorage(`Сетевая ошибка при отправке файла ${fileObj.name}: ${fileError.message}`);
                        }
                    }
                }

                // 3. НОВОЕ: Очищаем только отправленные товары из IndexedDB
                await cleanupSentProducts();

                // 4. Помечаем что заказ отправлен
                localStorage.setItem('telegram_sent', 'true');
                localStorage.setItem('telegram_sent_time', new Date().toISOString());
                logToLocalStorage('ЗАКАЗ УСПЕШНО ОТПРАВЛЕН В TELEGRAM');

                return true;

            } catch (error) {
                logToLocalStorage(`Сетевая ошибка отправки: ${error.message}`);
                return false;
            } finally {
                // Освобождаем флаг в любом случае
                window.telegramSending = false;
            }
        }
    }

    // НОВАЯ ФУНКЦИЯ: Очистка отправленных товаров
    async function cleanupSentProducts() {
        if (!window.TildaCartDB) {
            logToLocalStorage('TildaCartDB недоступен для очистки');
            return;
        }

        try {
            const db = new TildaCartDB();
            await db.init();

            // Получаем товары которые только что отправили
            const sentProducts = await getCurrentOrderProducts();

            logToLocalStorage(`Очищаем ${sentProducts.length} отправленных товаров`);

            // Удаляем каждый отправленный товар по SKU
            for (const product of sentProducts) {
                if (product.sku) {
                    await db.removeProductBySku(product.sku);
                    logToLocalStorage(`Удален товар с SKU: ${product.sku}`);
                }
            }

            logToLocalStorage('Очистка IndexedDB завершена');

        } catch (error) {
            logToLocalStorage(`Ошибка очистки IndexedDB: ${error.message}`);
        }
    }

    // ===== УСИЛЕННЫЙ ПЕРЕХВАТ API ===== //
    function setupEnhancedApiIntercept() {
        logToLocalStorage('🚀 УСТАНАВЛИВАЕМ УСИЛЕННЫЙ ПЕРЕХВАТ API');

        // МАКСИМАЛЬНО РАСШИРЕННЫЙ список API endpoints
        const apiEndpoints = [
            // Основные Tilda API
            'forms.tildaapi.com',
            'forms.tildacdn.com',
            'store.tildaapi.com',
            'tildaapi.com',
            'tilda.cc',

            // Возможные пути
            '/procces/',
            '/payment/',
            '/api/',
            '/order/',
            '/checkout/',
            '/cart/',
            '/submit/',
            '/process/',

            // Дополнительные варианты
            'api.tilda',
            '/api/order',
            '/api/checkout',
            '/order/create',
            '/payment/create',
            '/cart/checkout',
            '/store/order',
            '/form/submit'
        ];

        // === ПЕРЕХВАТ FETCH === //
        const originalFetch = window.fetch;
        window.fetch = async function (...args) {
            const url = args[0] ? args[0].toString() : '';
            const method = args[1] ? args[1].method : 'GET';

            // Проверяем все API endpoints
            const isApiRequest = apiEndpoints.some(endpoint => url.includes(endpoint));

            if (isApiRequest) {
                logToLocalStorage(`🔍 ПЕРЕХВАЧЕН FETCH: ${method} ${url}`);

                // Логируем данные запроса
                if (args[1] && args[1].body) {
                    const bodyPreview = args[1].body.toString().substring(0, 300);
                    logToLocalStorage(`📤 Данные запроса: ${bodyPreview}...`);

                    // Извлекаем данные клиента из запроса
                    try {
                        const formData = new URLSearchParams(args[1].body);
                        const customerData = {
                            name: formData.get('name') || formData.get('Name') || 'Не указано',
                            email: formData.get('email') || formData.get('Email') || 'Не указано',
                            phone: formData.get('phone') || formData.get('Phone') || 'Не указано'
                        };

                        if (customerData.name !== 'Не указано' || customerData.email !== 'Не указано' || customerData.phone !== 'Не указано') {
                            logToLocalStorage(`👤 ДАННЫЕ КЛИЕНТА из запроса: ${JSON.stringify(customerData)}`);
                            localStorage.setItem('tilda_customer_data', JSON.stringify(customerData));
                        }
                    } catch (error) {
                        logToLocalStorage(`❌ Ошибка парсинга данных запроса: ${error.message}`);
                    }
                }
            }

            // Выполняем оригинальный запрос
            const response = await originalFetch.apply(this, args);

            // Обрабатываем ответ от API
            if (isApiRequest) {
                try {
                    const clonedResponse = response.clone();
                    const responseText = await clonedResponse.text();

                    logToLocalStorage(`📥 ОТВЕТ от API (${response.status}): ${responseText.substring(0, 300)}...`);

                    // Парсим JSON ответ
                    const responseData = JSON.parse(responseText);

                    // СУПЕРРАСШИРЕННЫЙ поиск номера заказа
                    let orderNumber = extractOrderNumber(responseData);

                    if (orderNumber) {
                        logToLocalStorage(`🎯 НАЙДЕН НОМЕР ЗАКАЗА: ${orderNumber}`);

                        // Сохраняем все данные
                        localStorage.setItem('tilda_order_id', orderNumber);
                        localStorage.setItem('order_created_time', Date.now().toString());
                        localStorage.removeItem('telegram_sent');

                        logToLocalStorage('💾 Номер заказа сохранен, запускаем отправку');

                        // Немедленная отправка
                        setTimeout(() => {
                            logToLocalStorage('🚀 ЗАПУСКАЕМ ОТПРАВКУ ЗАКАЗА');
                            sendOrderToTelegram();
                        }, 1000);
                    }

                    // Извлекаем цену из API
                    extractPriceFromResponse(responseData);

                } catch (error) {
                    logToLocalStorage(`❌ Ошибка обработки ответа: ${error.message}`);
                }
            }

            return response;
        };

        // === ПЕРЕХВАТ XMLHttpRequest === //
        const originalXHR = window.XMLHttpRequest;
        const originalOpen = XMLHttpRequest.prototype.open;
        const originalSend = XMLHttpRequest.prototype.send;

        XMLHttpRequest.prototype.open = function (method, url, ...args) {
            this._method = method;
            this._url = url;

            const isApiRequest = apiEndpoints.some(endpoint => url.includes(endpoint));
            if (isApiRequest) {
                logToLocalStorage(`🔍 XHR OPEN: ${method} ${url}`);
            }

            return originalOpen.apply(this, [method, url, ...args]);
        };

        XMLHttpRequest.prototype.send = function (data) {
            const isApiRequest = this._url && apiEndpoints.some(endpoint => this._url.includes(endpoint));

            if (this._method === 'POST' && isApiRequest) {
                logToLocalStorage(`📤 XHR POST: ${this._url}`);

                if (data) {
                    const dataPreview = data.toString().substring(0, 300);
                    logToLocalStorage(`📤 XHR данные: ${dataPreview}...`);

                    // Извлекаем данные клиента
                    try {
                        const formData = new URLSearchParams(data);
                        const customerData = {
                            name: formData.get('name') || formData.get('Name') || 'Не указано',
                            email: formData.get('email') || formData.get('Email') || 'Не указано',
                            phone: formData.get('phone') || formData.get('Phone') || 'Не указано'
                        };

                        if (customerData.name !== 'Не указано' || customerData.email !== 'Не указано' || customerData.phone !== 'Не указано') {
                            logToLocalStorage(`👤 XHR ДАННЫЕ КЛИЕНТА: ${JSON.stringify(customerData)}`);
                            localStorage.setItem('tilda_customer_data', JSON.stringify(customerData));
                        }
                    } catch (error) {
                        logToLocalStorage(`❌ Ошибка парсинга XHR данных: ${error.message}`);
                    }
                }
            }

            // Перехватываем ответ
            this.addEventListener('load', function () {
                const isApiResponse = this.responseURL && apiEndpoints.some(endpoint => this.responseURL.includes(endpoint));

                if (isApiResponse) {
                    logToLocalStorage(`📥 XHR ОТВЕТ от: ${this.responseURL} (${this.status})`);

                    try {
                        const responseText = this.responseText;
                        logToLocalStorage(`📥 XHR данные: ${responseText.substring(0, 300)}...`);

                        const responseData = JSON.parse(responseText);

                        // Ищем номер заказа
                        let orderNumber = extractOrderNumber(responseData);

                        if (orderNumber) {
                            logToLocalStorage(`🎯 XHR НАЙДЕН НОМЕР ЗАКАЗА: ${orderNumber}`);

                            localStorage.setItem('tilda_order_id', orderNumber);
                            localStorage.setItem('order_created_time', Date.now().toString());
                            localStorage.removeItem('telegram_sent');

                            setTimeout(() => {
                                logToLocalStorage('🚀 XHR: ЗАПУСКАЕМ ОТПРАВКУ ЗАКАЗА');
                                sendOrderToTelegram();
                            }, 1000);
                        }

                        // Извлекаем цену
                        extractPriceFromResponse(responseData);

                    } catch (error) {
                        logToLocalStorage(`❌ Ошибка обработки XHR ответа: ${error.message}`);
                    }
                }
            });

            return originalSend.apply(this, arguments);
        };

        logToLocalStorage('✅ УСИЛЕННЫЙ ПЕРЕХВАТ API установлен (fetch + XHR)');
    }

    // ФУНКЦИЯ: Извлечение номера заказа из любого ответа
    function extractOrderNumber(responseData) {
        logToLocalStorage('🔍 Ищем номер заказа в ответе...');

        // Все возможные варианты номера заказа
        const orderFields = [
            'results',
            'result',
            'order_id',
            'orderId',
            'orderid',
            'id',
            'order.id',
            'order_number',
            'orderNumber',
            'number',
            'transaction_id',
            'transactionId',
            'payment_id',
            'paymentId'
        ];

        for (const field of orderFields) {
            let value = null;

            // Простое поле
            if (responseData[field]) {
                value = responseData[field];
            }
            // Вложенное поле (например order.id)
            else if (field.includes('.')) {
                const parts = field.split('.');
                let obj = responseData;
                for (const part of parts) {
                    if (obj && obj[part]) {
                        obj = obj[part];
                    } else {
                        obj = null;
                        break;
                    }
                }
                value = obj;
            }

            // Проверяем значение
            if (value) {
                // Если это массив - берем первый элемент
                if (Array.isArray(value) && value.length > 0) {
                    value = value[0];
                }

                // Если это объект - ищем поле id
                if (typeof value === 'object' && value.id) {
                    value = value.id;
                }

                // Проверяем что это валидный номер заказа
                if (typeof value === 'string' || typeof value === 'number') {
                    const orderStr = value.toString();
                    if (orderStr.length > 0) {
                        logToLocalStorage(`✅ Найден номер заказа в поле "${field}": ${orderStr}`);
                        return orderStr;
                    }
                }
            }
        }

        logToLocalStorage('❌ Номер заказа не найден ни в одном поле');
        return null;
    }

    // ФУНКЦИЯ: Извлечение цены из API ответа
    function extractPriceFromResponse(responseData) {
        const priceFields = ['price', 'amount', 'total', 'sum', 'cost'];

        // Ищем в продуктах
        if (responseData.products && Array.isArray(responseData.products)) {
            responseData.products.forEach(product => {
                for (const field of priceFields) {
                    if (product[field]) {
                        localStorage.setItem('last_api_price', product[field]);
                        logToLocalStorage(`💰 Сохранена цена из API (products.${field}): ${product[field]}`);
                        return;
                    }
                }
            });
        }

        // Ищем в корневом объекте
        for (const field of priceFields) {
            if (responseData[field]) {
                localStorage.setItem('last_api_price', responseData[field]);
                logToLocalStorage(`💰 Сохранена цена из API (${field}): ${responseData[field]}`);
                return;
            }
        }
    }

    // УЛУЧШЕННАЯ резервная система отправки + Polling (БЕЗ ДУБЛИРОВАНИЯ)
    function setupEnhancedBackupSystem() {
        logToLocalStorage('⏰ Устанавливаем усиленную резервную систему БЕЗ дублирования');

        let isProcessing = false; // Флаг для предотвращения дублирования

        // Быстрый polling каждые 2 секунды
        const quickPolling = setInterval(() => {
            const orderId = localStorage.getItem('tilda_order_id');
            const sent = localStorage.getItem('telegram_sent');

            if (orderId && !sent && !isProcessing) {
                isProcessing = true; // Блокируем повторную отправку
                logToLocalStorage(`⚡ QUICK POLLING: Найден заказ ${orderId}, запускаем отправку`);

                sendOrderToTelegram().finally(() => {
                    isProcessing = false; // Разблокируем после завершения
                    clearInterval(quickPolling); // Останавливаем быстрый polling после отправки
                });
            }
        }, 2000);

        // Резервная проверка каждые 5 секунд (с защитой от дублирования)
        setInterval(() => {
            const orderId = localStorage.getItem('tilda_order_id');
            const orderTime = localStorage.getItem('order_created_time');
            const sent = localStorage.getItem('telegram_sent');

            if (orderId && orderTime && !sent && !isProcessing) {
                const timePassed = Date.now() - parseInt(orderTime);
                if (timePassed > 8000) { // Если прошло больше 8 секунд
                    isProcessing = true;
                    logToLocalStorage(`⏰ РЕЗЕРВНАЯ ОТПРАВКА: прошло ${Math.round(timePassed / 1000)} сек`);
                    sendOrderToTelegram().finally(() => {
                        isProcessing = false;
                    });
                }
            }
        }, 5000);

        // Защита от закрытия страницы (с проверкой флага)
        window.addEventListener('beforeunload', (event) => {
            const orderId = localStorage.getItem('tilda_order_id');
            const sent = localStorage.getItem('telegram_sent');

            if (orderId && !sent && !isProcessing) {
                logToLocalStorage('🚨 beforeunload: Попытка экстренной отправки');

                // Быстрая отправка через sendBeacon
                const customer = getCustomerData();
                const quickMessage = `ЭКСТРЕННЫЙ ЗАКАЗ!\nНомер: ${orderId}\nКлиент: ${customer.name}\nEmail: ${customer.email}\nТелефон: ${customer.phone}\nВремя: ${new Date().toLocaleString()}`;

                const data = JSON.stringify({
                    chat_id: TELEGRAM_CHAT_ID,
                    text: quickMessage
                });

                navigator.sendBeacon(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`,
                    new Blob([data], { type: 'application/json' }));

                localStorage.setItem('telegram_sent', 'beforeunload');
            }
        });

        logToLocalStorage('✅ Усиленная резервная система установлена БЕЗ дублирования');
    }

    // Глобальные функции для тестирования
    window.telegramSimple = {
        async sendOrder() {
            logToLocalStorage('🔥 ПРИНУДИТЕЛЬНАЯ ОТПРАВКА через sendOrder()');
            return await sendOrderToTelegram();
        },

        checkCustomerData() {
            const customer = getCustomerData();
            console.log('[TELEGRAM] Данные клиента:', customer);
            return customer;
        },

        async checkProducts() {
            const products = await getCurrentOrderProducts();
            console.log('[TELEGRAM] Товары текущего заказа:', products);
            return products;
        },

        async checkAllProducts() {
            if (window.TildaCartDB) {
                try {
                    const db = new TildaCartDB();
                    await db.init();
                    const products = await db.getAllProducts();
                    console.log('[TELEGRAM] ВСЕ товары в IndexedDB:', products);
                    return products;
                } catch (error) {
                    console.error('[TELEGRAM] Ошибка IndexedDB:', error);
                    return [];
                }
            } else {
                console.log('[TELEGRAM] TildaCartDB недоступен');
                return [];
            }
        },

        checkOrderNumber() {
            const orderNumber = getOrderNumber();
            console.log('[TELEGRAM] Номер заказа:', orderNumber);
            return orderNumber;
        },

        setOrderNumber(orderNumber) {
            localStorage.setItem('tilda_order_id', orderNumber);
            localStorage.setItem('order_created_time', Date.now().toString());
            localStorage.removeItem('telegram_sent');
            logToLocalStorage(`🔧 Номер заказа установлен вручную: ${orderNumber}`);
        },

        clearStorage() {
            localStorage.removeItem('tilda_order_id');
            localStorage.removeItem('tilda_customer_data');
            localStorage.removeItem('telegram_sent');
            localStorage.removeItem('order_created_time');
            localStorage.removeItem('last_api_price');
            logToLocalStorage('🧹 localStorage очищен');
        },

        showLogs() {
            const logs = JSON.parse(localStorage.getItem('telegram_debug_logs') || '[]');
            console.log('=== TELEGRAM DEBUG LOGS ===');
            logs.forEach(log => console.log(log));
            return logs;
        },

        clearLogs() {
            localStorage.removeItem('telegram_debug_logs');
            logToLocalStorage('🧹 Логи очищены');
        },

        checkStatus() {
            const orderId = localStorage.getItem('tilda_order_id');
            const sent = localStorage.getItem('telegram_sent');
            const orderTime = localStorage.getItem('order_created_time');
            const apiPrice = localStorage.getItem('last_api_price');
            const customerData = localStorage.getItem('tilda_customer_data');

            const status = {
                orderId,
                sent: !!sent,
                sentValue: sent,
                orderTime: orderTime ? new Date(parseInt(orderTime)).toLocaleString() : null,
                apiPrice,
                customerData: customerData ? JSON.parse(customerData) : null,
                logsCount: JSON.parse(localStorage.getItem('telegram_debug_logs') || '[]').length
            };

            console.log('=== TELEGRAM STATUS ===', status);
            return status;
        },

        async cleanupIndexedDB() {
            await cleanupSentProducts();
            console.log('[TELEGRAM] IndexedDB очищен принудительно');
        },

        testApiIntercept() {
            logToLocalStorage('🧪 ТЕСТ: Проверяем работу API перехвата');

            // Делаем несколько тестовых запросов
            const testUrls = [
                'https://forms.tildaapi.com/procces/',
                'https://store.tildaapi.com/api/',
                'https://forms.tilda.cc/test'
            ];

            testUrls.forEach(url => {
                fetch(url, {
                    method: 'POST',
                    body: 'test=1'
                }).catch(() => {
                    logToLocalStorage(`🧪 ТЕСТ: Запрос к ${url} выполнен (ошибка ожидаема)`);
                });
            });
        },

        async fullDiagnostic() {
            console.log('=== 🔍 ПОЛНАЯ ДИАГНОСТИКА TELEGRAM СКРИПТА ===');

            const diagnostic = {
                timestamp: new Date().toISOString(),
                version: 'УСИЛЕННЫЙ ПЕРЕХВАТ v2.0',
                orderNumber: this.checkOrderNumber(),
                customerData: this.checkCustomerData(),
                currentProducts: await this.checkProducts(),
                allProducts: await this.checkAllProducts(),
                status: this.checkStatus(),
                interceptStatus: {
                    fetchOverridden: window.fetch.toString().includes('originalFetch'),
                    xhrOverridden: XMLHttpRequest.prototype.send.toString().includes('originalSend')
                },
                logs: this.showLogs()
            };

            console.log('🎯 ДИАГНОСТИКА ЗАВЕРШЕНА:', diagnostic);
            return diagnostic;
        },

        // НОВАЯ ФУНКЦИЯ: Симуляция API ответа для тестирования
        simulateOrderResponse(orderNumber = 'TEST123') {
            logToLocalStorage(`🎭 СИМУЛЯЦИЯ: API ответ с заказом ${orderNumber}`);

            const mockResponse = {
                results: [orderNumber],
                order_id: orderNumber,
                status: 'success'
            };

            // Симулируем обработку ответа
            const extractedOrder = extractOrderNumber(mockResponse);

            if (extractedOrder) {
                localStorage.setItem('tilda_order_id', extractedOrder);
                localStorage.setItem('order_created_time', Date.now().toString());
                localStorage.removeItem('telegram_sent');

                setTimeout(() => {
                    logToLocalStorage('🎭 СИМУЛЯЦИЯ: Запускаем отправку');
                    sendOrderToTelegram();
                }, 1000);
            }
        },

        // НОВАЯ ФУНКЦИЯ: Мониторинг localStorage
        startMonitoring() {
            logToLocalStorage('👁️ Запускаем мониторинг localStorage');

            const monitor = setInterval(() => {
                const orderId = localStorage.getItem('tilda_order_id');
                const sent = localStorage.getItem('telegram_sent');

                if (orderId && !sent) {
                    console.log(`👁️ МОНИТОРИНГ: Заказ ${orderId} найден, отправка...`);
                    sendOrderToTelegram();
                    clearInterval(monitor);
                }
            }, 1000);

            setTimeout(() => {
                clearInterval(monitor);
                logToLocalStorage('👁️ Мониторинг завершен (таймаут)');
            }, 60000); // Мониторинг 1 минуту
        }
    };

    // Инициализация при загрузке (с защитой от дублирования)
    function initializeScript() {
        logToLocalStorage('🚀 ИНИЦИАЛИЗАЦИЯ УСИЛЕННОГО TELEGRAM СКРИПТА');

        // Устанавливаем только XHR перехват
        setupEnhancedApiIntercept();
        setupEnhancedBackupSystem();

        // Проверяем есть ли уже заказ (с защитой от дублирования)
        const existingOrder = localStorage.getItem('tilda_order_id');
        const alreadySent = localStorage.getItem('telegram_sent');

        if (existingOrder && !alreadySent) {
            logToLocalStorage(`🔄 Найден необработанный заказ: ${existingOrder}`);

            // Устанавливаем флаг обработки чтобы избежать конфликта с polling
            let initProcessing = true;
            setTimeout(() => {
                if (initProcessing && !localStorage.getItem('telegram_sent')) {
                    sendOrderToTelegram().finally(() => {
                        initProcessing = false;
                    });
                }
            }, 2000);

            // Снимаем флаг через 10 секунд в любом случае
            setTimeout(() => {
                initProcessing = false;
            }, 10000);
        }

        logToLocalStorage('✅ УСИЛЕННЫЙ TELEGRAM СКРИПТ полностью инициализирован БЕЗ дублирования');
    }

    // Запускаем при загрузке DOM
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeScript);
    } else {
        initializeScript();
    }

    console.log(`
🚀 === XHR TELEGRAM СКРИПТ v3.0 ===
Скрипт успешно загружен!

🔥 ОПТИМИЗАЦИИ:
• Только XHR перехват (убран FETCH)
• Немедленная отправка без задержек
• Усиленная защита от дублирования
• Глубокий поиск в JSON структурах
• Мониторинг localStorage в реальном времени

📋 КОМАНДЫ ДЛЯ ТЕСТИРОВАНИЯ:
• window.telegramSimple.fullDiagnostic() - полная диагностика
• window.telegramSimple.simulateOrderResponse('123') - симуляция заказа
• window.telegramSimple.startMonitoring() - мониторинг localStorage
• window.telegramSimple.testApiIntercept() - тест перехвата
• window.telegramSimple.sendOrder() - принудительная отправка
• window.telegramSimple.showLogs() - все логи
• window.telegramSimple.checkStatus() - текущий статус

🎯 АВТОМАТИЧЕСКИЕ СИСТЕМЫ:
• API перехват: ТОЛЬКО XMLHttpRequest
• Поиск заказа: 12+ различных полей в JSON
• Резервная отправка: 8 секунд задержки
• Экстренная отправка: при закрытии страницы
• Автоочистка: IndexedDB после отправки

🔍 ДИАГНОСТИКА:
1. Сделайте заказ
2. Выполните: window.telegramSimple.fullDiagnostic()
3. Проверьте логи: window.telegramSimple.showLogs()
4. При проблемах: window.telegramSimple.simulateOrderResponse()
`);
</script>